{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/google-genai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;;;;;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,kKAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/ai/flows/chat-helper.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A general-purpose AI chat helper flow.\n *\n * - chat - A function that takes a chat history and returns a response.\n * - ChatInput - The input type for the chat function.\n * - ChatOutput - The return type for the chat function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst ChatMessageSchema = z.object({\n  role: z.enum(['user', 'model']),\n  content: z.string(),\n});\n\nconst ChatInputSchema = z.object({\n  history: z.array(ChatMessageSchema),\n});\nexport type ChatInput = z.infer<typeof ChatInputSchema>;\n\nconst ChatOutputSchema = z.object({\n  response: z.string(),\n});\nexport type ChatOutput = z.infer<typeof ChatOutputSchema>;\n\nexport async function chat(input: ChatInput): Promise<ChatOutput> {\n  return chatHelperFlow(input);\n}\n\nconst chatHelperFlow = ai.defineFlow(\n  {\n    name: 'chatHelperFlow',\n    inputSchema: ChatInputSchema,\n    outputSchema: ChatOutputSchema,\n  },\n  async (input) => {\n    let retries = 0;\n    const maxRetries = 2;\n\n    while (retries <= maxRetries) {\n      try {\n        const llmResponse = await ai.generate({\n          prompt: input.history.slice(-1)[0]?.content || '', // Use last user message as prompt\n          history: [\n            {\n              role: 'user',\n              content: `You are a friendly and knowledgeable AI assistant for a GCSE History revision website called HistoryStudies.net.\nYour purpose is to help students understand historical concepts for the Edexcel (Pearson) syllabus.\nYour expertise covers the following topics:\n- Superpower Relations and the Cold War\n- Weimar and Nazi Germany\n- Medicine in Britain, c.1250-present\n- Anglo-Saxon England and the Norman Conquest (1060-66)\n\nBe encouraging and clear in your explanations.\nKeep responses concise and easy to understand for a 15-16 year old student.\nUse the provided chat history to maintain context.\n`,\n            },\n            ...input.history.slice(0, -1),\n          ],\n          output: {\n            schema: ChatOutputSchema,\n          },\n        });\n\n        const output = llmResponse.output;\n        if (output) {\n          return output;\n        }\n        throw new Error('Empty response from AI.');\n      } catch (error: any) {\n        if (error.status === 429 || error.status === 503) {\n          retries++;\n          if (retries > maxRetries) {\n            return { response: 'The AI is currently busy. Please try again in a moment.' };\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000 * retries));\n        } else {\n           return { response: 'Sorry, I had trouble thinking of a response.' };\n        }\n      }\n    }\n     return { response: 'Sorry, I had trouble thinking of a response.' };\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;;;;;AAEA,MAAM,oBAAoB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACjC,MAAM,uIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;QAAC;QAAQ;KAAQ;IAC9B,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM;AACnB;AAEA,MAAM,kBAAkB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC/B,SAAS,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC;AACnB;AAGA,MAAM,mBAAmB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM;AACpB;AAGO,eAAe,KAAK,KAAgB;IACzC,OAAO,eAAe;AACxB;AAEA,MAAM,iBAAiB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAClC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,IAAI,UAAU;IACd,MAAM,aAAa;IAEnB,MAAO,WAAW,WAAY;QAC5B,IAAI;YACF,MAAM,cAAc,MAAM,mHAAA,CAAA,KAAE,CAAC,QAAQ,CAAC;gBACpC,QAAQ,MAAM,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,WAAW;gBAC/C,SAAS;oBACP;wBACE,MAAM;wBACN,SAAS,CAAC;;;;;;;;;;;AAWxB,CAAC;oBACW;uBACG,MAAM,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC;iBAC5B;gBACD,QAAQ;oBACN,QAAQ;gBACV;YACF;YAEA,MAAM,SAAS,YAAY,MAAM;YACjC,IAAI,QAAQ;gBACV,OAAO;YACT;YACA,MAAM,IAAI,MAAM;QAClB,EAAE,OAAO,OAAY;YACnB,IAAI,MAAM,MAAM,KAAK,OAAO,MAAM,MAAM,KAAK,KAAK;gBAChD;gBACA,IAAI,UAAU,YAAY;oBACxB,OAAO;wBAAE,UAAU;oBAA0D;gBAC/E;gBACA,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,OAAO;YAC5D,OAAO;gBACJ,OAAO;oBAAE,UAAU;gBAA+C;YACrE;QACF;IACF;IACC,OAAO;QAAE,UAAU;IAA+C;AACrE;;;IA3DoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/ai/flows/generate-written-question.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A flow for generating a single open-ended written question for a given topic.\n *\n * - generateWrittenQuestion - A function that generates a written question.\n * - GenerateWrittenQuestionInput - The input type for the function.\n * - GenerateWrittenQuestionOutput - The return type for the function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst GenerateWrittenQuestionInputSchema = z.object({\n  topic: z\n    .string()\n    .describe('The topic or subject matter for which to generate a question.'),\n  marks: z.number().min(1).max(6).describe('The number of marks the question is worth. Typical values are 2, 4, or 6.')\n});\nexport type GenerateWrittenQuestionInput = z.infer<\n  typeof GenerateWrittenQuestionInputSchema\n>;\n\nconst GenerateWrittenQuestionOutputSchema = z.object({\n  question: z.string().describe('The generated open-ended question.'),\n  answer: z.string().describe('A concise, ideal answer to the question.'),\n  explanation: z\n    .string()\n    .describe('A detailed mark scheme explaining how marks are awarded. Use bullet points for clarity.'),\n  marks: z.number().describe('The number of marks the question is worth.')\n});\nexport type GenerateWrittenQuestionOutput = z.infer<\n  typeof GenerateWrittenQuestionOutputSchema\n>;\n\nexport async function generateWrittenQuestion(\n  input: GenerateWrittenQuestionInput\n): Promise<GenerateWrittenQuestionOutput> {\n  return generateWrittenQuestionFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateWrittenQuestionPrompt',\n  input: { schema: GenerateWrittenQuestionInputSchema },\n  output: { schema: GenerateWrittenQuestionOutputSchema },\n  prompt: `You are an expert AQA GCSE Science examiner.\n  Generate a single, challenging, open-ended exam-style question for the following topic worth {{marks}} marks.\n  The question should require a written answer, not a multiple-choice selection.\n  Also provide a concise, ideal answer and a detailed mark scheme. The mark scheme should be broken down into bullet points, explaining exactly where each mark comes from.\n  Ensure the 'marks' field in the output JSON is set to {{marks}}.\n\n  Topic: {{{topic}}}\n  `,\n});\n\nconst generateWrittenQuestionFlow = ai.defineFlow(\n  {\n    name: 'generateWrittenQuestionFlow',\n    inputSchema: GenerateWrittenQuestionInputSchema,\n    outputSchema: GenerateWrittenQuestionOutputSchema,\n  },\n  async (input) => {\n    let retries = 0;\n    const maxRetries = 2;\n\n    while (retries <= maxRetries) {\n      try {\n        const { output } = await prompt(input);\n        if (!output) {\n          throw new Error('Generated written question output was empty.');\n        }\n        return output;\n      } catch (error: any) {\n        if (error.status === 429 || error.status === 503) {\n          retries++;\n          if (retries > maxRetries) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000 * retries));\n        } else {\n          throw error;\n        }\n      }\n    }\n    throw new Error('Failed to generate written question after multiple retries.');\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;;;;;AAEA,MAAM,qCAAqC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClD,OAAO,uIAAA,CAAA,IAAC,CACL,MAAM,GACN,QAAQ,CAAC;IACZ,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,QAAQ,CAAC;AAC3C;AAKA,MAAM,sCAAsC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnD,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,aAAa,uIAAA,CAAA,IAAC,CACX,MAAM,GACN,QAAQ,CAAC;IACZ,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC7B;AAKO,eAAe,wBACpB,KAAmC;IAEnC,OAAO,4BAA4B;AACrC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAAmC;IACpD,QAAQ;QAAE,QAAQ;IAAoC;IACtD,QAAQ,CAAC;;;;;;;EAOT,CAAC;AACH;AAEA,MAAM,8BAA8B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC/C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,IAAI,UAAU;IACd,MAAM,aAAa;IAEnB,MAAO,WAAW,WAAY;QAC5B,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,OAAO;YAChC,IAAI,CAAC,QAAQ;gBACX,MAAM,IAAI,MAAM;YAClB;YACA,OAAO;QACT,EAAE,OAAO,OAAY;YACnB,IAAI,MAAM,MAAM,KAAK,OAAO,MAAM,MAAM,KAAK,KAAK;gBAChD;gBACA,IAAI,UAAU,YAAY;oBACxB,MAAM;gBACR;gBACA,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,OAAO;YAC5D,OAAO;gBACL,MAAM;YACR;QACF;IACF;IACA,MAAM,IAAI,MAAM;AAClB;;;IAlDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/ai/flows/generate-cloze-test.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A flow for generating a fill-in-the-gaps (cloze) test for a given topic.\n *\n * - generateClozeTest - A function that generates a cloze test.\n * - GenerateClozeTestInput - The input type for the function.\n * - GenerateClozeTestOutput - The return type for the function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst ClozeQuestionSchema = z.object({\n  sentence: z\n    .string()\n    .describe(\n      'A sentence with a key term replaced by \"______\" (six underscores).'\n    ),\n  answer: z.string().describe('The word that was removed from the sentence.'),\n});\n\nconst GenerateClozeTestInputSchema = z.object({\n  topic: z\n    .string()\n    .describe('The topic or subject matter for which to generate the test.'),\n});\nexport type GenerateClozeTestInput = z.infer<typeof GenerateClozeTestInputSchema>;\n\nconst GenerateClozeTestOutputSchema = z.object({\n  title: z.string().describe('The title of the cloze test.'),\n  questions: z.array(ClozeQuestionSchema),\n});\nexport type GenerateClozeTestOutput = z.infer<typeof GenerateClozeTestOutputSchema>;\n\n\nexport async function generateClozeTest(\n  input: GenerateClozeTestInput\n): Promise<GenerateClozeTestOutput> {\n  return generateClozeTestFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateClozeTestPrompt',\n  input: { schema: GenerateClozeTestInputSchema },\n  output: { schema: GenerateClozeTestOutputSchema },\n  prompt: `You are an expert AQA GCSE Science examiner.\n  Create a \"fill-in-the-gaps\" (cloze) test with 8 sentences for the given topic.\n  Each sentence should test a key concept or vocabulary word.\n  Replace a single, important keyword in each sentence with \"______\" (six underscores).\n\n  Topic: {{{topic}}}\n  `,\n});\n\nconst generateClozeTestFlow = ai.defineFlow(\n  {\n    name: 'generateClozeTestFlow',\n    inputSchema: GenerateClozeTestInputSchema,\n    outputSchema: GenerateClozeTestOutputSchema,\n  },\n  async (input) => {\n    let retries = 0;\n    const maxRetries = 2;\n\n    while (retries <= maxRetries) {\n      try {\n        const { output } = await prompt(input);\n        if (!output) {\n          throw new Error('Generated cloze test output was empty.');\n        }\n        return output;\n      } catch (error: any) {\n        if (error.status === 429 || error.status === 503) {\n          retries++;\n          if (retries > maxRetries) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000 * retries));\n        } else {\n          throw error;\n        }\n      }\n    }\n    throw new Error('Failed to generate cloze test after multiple retries.');\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;;;;;AAEA,MAAM,sBAAsB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnC,UAAU,uIAAA,CAAA,IAAC,CACR,MAAM,GACN,QAAQ,CACP;IAEJ,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B;AAEA,MAAM,+BAA+B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5C,OAAO,uIAAA,CAAA,IAAC,CACL,MAAM,GACN,QAAQ,CAAC;AACd;AAGA,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC3B,WAAW,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC;AACrB;AAIO,eAAe,kBACpB,KAA6B;IAE7B,OAAO,sBAAsB;AAC/B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAA6B;IAC9C,QAAQ;QAAE,QAAQ;IAA8B;IAChD,QAAQ,CAAC;;;;;;EAMT,CAAC;AACH;AAEA,MAAM,wBAAwB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACzC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,IAAI,UAAU;IACd,MAAM,aAAa;IAEnB,MAAO,WAAW,WAAY;QAC5B,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,OAAO;YAChC,IAAI,CAAC,QAAQ;gBACX,MAAM,IAAI,MAAM;YAClB;YACA,OAAO;QACT,EAAE,OAAO,OAAY;YACnB,IAAI,MAAM,MAAM,KAAK,OAAO,MAAM,MAAM,KAAK,KAAK;gBAChD;gBACA,IAAI,UAAU,YAAY;oBACxB,MAAM;gBACR;gBACA,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,OAAO;YAC5D,OAAO;gBACL,MAAM;YACR;QACF;IACF;IACA,MAAM,IAAI,MAAM;AAClB;;;IAjDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 553, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/ai/flows/explain-exam-question.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A flow for explaining an exam question to a student.\n *\n * - explainExamQuestion - A function that provides a helpful explanation.\n * - ExplainExamQuestionInput - The input type for the function.\n * - ExplainExamQuestionOutput - The return type for the function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst ExplainExamQuestionInputSchema = z.object({\n  question: z.string().describe('The exam question the student needs help with.'),\n  topic: z.string().describe('The subject topic of the question.'),\n});\nexport type ExplainExamQuestionInput = z.infer<typeof ExplainExamQuestionInputSchema>;\n\nconst ExplainExamQuestionOutputSchema = z.object({\n  explanation: z\n    .string()\n    .describe(\n      'A helpful explanation of the question. It should break down the question, define key scientific terms, and hint at how to structure a good answer without giving the answer away directly.'\n    ),\n});\nexport type ExplainExamQuestionOutput = z.infer<typeof ExplainExamQuestionOutputSchema>;\n\nexport async function explainExamQuestion(\n  input: ExplainExamQuestionInput\n): Promise<ExplainExamQuestionOutput> {\n  return explainExamQuestionFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'explainExamQuestionPrompt',\n  input: { schema: ExplainExamQuestionInputSchema },\n  output: { schema: ExplainExamQuestionOutputSchema },\n  prompt: `You are a friendly and encouraging GCSE Science tutor. A student is stuck on an exam question and has asked for help.\n\nYour task is to explain the question to them. Do NOT give them the answer.\n\nInstead, you should:\n1.  Break down the question into smaller parts.\n2.  Define any key scientific terms in the question.\n3.  Explain the core concepts the question is testing.\n4.  Give them a hint about how to structure their answer or what to include.\n5.  Keep your tone supportive and helpful.\n\nTopic: {{{topic}}}\nQuestion: \"{{{question}}}\"\n`,\n});\n\nconst explainExamQuestionFlow = ai.defineFlow(\n  {\n    name: 'explainExamQuestionFlow',\n    inputSchema: ExplainExamQuestionInputSchema,\n    outputSchema: ExplainExamQuestionOutputSchema,\n  },\n  async (input) => {\n     let retries = 0;\n    const maxRetries = 2;\n\n    while (retries <= maxRetries) {\n      try {\n        const { output } = await prompt(input);\n        if (!output) {\n          throw new Error('Generated explanation was empty.');\n        }\n        return output;\n      } catch (error: any) {\n        if (error.status === 429 || error.status === 503) {\n          retries++;\n          if (retries > maxRetries) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000 * retries));\n        } else {\n          throw error;\n        }\n      }\n    }\n    throw new Error('Failed to generate explanation after multiple retries.');\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;;;;;AAEA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC7B;AAGA,MAAM,kCAAkC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC/C,aAAa,uIAAA,CAAA,IAAC,CACX,MAAM,GACN,QAAQ,CACP;AAEN;AAGO,eAAe,oBACpB,KAA+B;IAE/B,OAAO,wBAAwB;AACjC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAA+B;IAChD,QAAQ;QAAE,QAAQ;IAAgC;IAClD,QAAQ,CAAC;;;;;;;;;;;;;AAaX,CAAC;AACD;AAEA,MAAM,0BAA0B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC3C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACJ,IAAI,UAAU;IACf,MAAM,aAAa;IAEnB,MAAO,WAAW,WAAY;QAC5B,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,OAAO;YAChC,IAAI,CAAC,QAAQ;gBACX,MAAM,IAAI,MAAM;YAClB;YACA,OAAO;QACT,EAAE,OAAO,OAAY;YACnB,IAAI,MAAM,MAAM,KAAK,OAAO,MAAM,MAAM,KAAK,KAAK;gBAChD;gBACA,IAAI,UAAU,YAAY;oBACxB,MAAM;gBACR;gBACA,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,OAAO;YAC5D,OAAO;gBACL,MAAM;YACR;QACF;IACF;IACA,MAAM,IAAI,MAAM;AAClB;;;IAxDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 649, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/ai/flows/grade-written-answer.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A flow for grading a student's written answer against a mark scheme.\n *\n * - gradeWrittenAnswer - A function that provides feedback on a written answer.\n * - GradeWrittenAnswerInput - The input type for the function.\n * - GradeWrittenAnswerOutput - The return type for the function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst GradeWrittenAnswerInputSchema = z.object({\n  question: z.string().describe('The exam question that was asked.'),\n  marks: z.number().describe('The number of marks the question is worth.'),\n  userAnswer: z.string().describe(\"The student's answer to the question.\"),\n  markScheme: z\n    .string()\n    .describe(\n      'The detailed mark scheme or model answer for the question.'\n    ),\n});\nexport type GradeWrittenAnswerInput = z.infer<\n  typeof GradeWrittenAnswerInputSchema\n>;\n\nconst GradeWrittenAnswerOutputSchema = z.object({\n  feedback: z\n    .string()\n    .describe(\n      'Detailed, constructive feedback for the student. It should be formatted as HTML and explain which marking points were hit and which were missed.'\n    ),\n  marksAwarded: z\n    .number()\n    .describe('The number of marks awarded for the answer.'),\n});\nexport type GradeWrittenAnswerOutput = z.infer<\n  typeof GradeWrittenAnswerOutputSchema\n>;\n\nexport async function gradeWrittenAnswer(\n  input: GradeWrittenAnswerInput\n): Promise<GradeWrittenAnswerOutput> {\n  return gradeWrittenAnswerFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'gradeWrittenAnswerPrompt',\n  input: { schema: GradeWrittenAnswerInputSchema },\n  output: { schema: GradeWrittenAnswerOutputSchema },\n  prompt: `You are an expert AQA GCSE Science examiner with a friendly and encouraging tone. Your task is to mark a student's answer against the provided mark scheme.\n\nYou must provide detailed, constructive feedback formatted in HTML. Do not just say if the answer is right or wrong. Explain *why*.\n\nYour feedback should follow this structure:\n1.  Start with a positive and encouraging opening.\n2.  Create a <ul> list. For each point in the mark scheme, create a <li>.\n3.  Inside each <li>, state the marking point. Then, say whether the student's answer achieved this point. Use a \"✅\" emoji if they got the point and a \"❌\" if they missed it.\n4.  Provide a brief quote or explanation of why they did or did not get the mark.\n5.  After the list, provide a summary of how they could improve.\n6.  Finally, determine the total marks awarded.\n\nExample response for a 2-mark question:\n\"<p>Great effort! Here's a breakdown of your answer:</p>\n<ul>\n    <li>✅ <strong>Marking Point:</strong> The student correctly identified that enzymes act as catalysts. <strong>Your Answer:</strong> You mentioned that 'enzymes speed up reactions', which is a perfect way to put it.</li>\n    <li>❌ <strong>Marking Point:</strong> The student did not mention that enzymes are proteins. <strong>Your Answer:</strong> You explained what enzymes do, but didn't mention what they are made of.</li>\n</ul>\n<p><strong>To improve:</strong> Next time, remember to also state that enzymes are a type of protein to secure that second mark. Well done on the first point!</p>\"\n\nHere is the information:\nQuestion: \"{{{question}}}\"\nMarks available: {{{marks}}}\nMark Scheme: \"{{{markScheme}}}\"\nStudent's Answer: \"{{{userAnswer}}}\"\n`,\n});\n\nconst gradeWrittenAnswerFlow = ai.defineFlow(\n  {\n    name: 'gradeWrittenAnswerFlow',\n    inputSchema: GradeWrittenAnswerInputSchema,\n    outputSchema: GradeWrittenAnswerOutputSchema,\n  },\n  async (input) => {\n    let retries = 0;\n    const maxRetries = 2;\n\n    while (retries <= maxRetries) {\n      try {\n        const { output } = await prompt(input);\n        if (!output) {\n          throw new Error('Generated grading output was empty.');\n        }\n        return output;\n      } catch (error: any) {\n        if (error.status === 429 || error.status === 503) {\n          retries++;\n          if (retries > maxRetries) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000 * retries));\n        } else {\n          throw error;\n        }\n      }\n    }\n    throw new Error('Failed to grade answer after multiple retries.');\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;;;;;AAEA,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC3B,YAAY,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAChC,YAAY,uIAAA,CAAA,IAAC,CACV,MAAM,GACN,QAAQ,CACP;AAEN;AAKA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,UAAU,uIAAA,CAAA,IAAC,CACR,MAAM,GACN,QAAQ,CACP;IAEJ,cAAc,uIAAA,CAAA,IAAC,CACZ,MAAM,GACN,QAAQ,CAAC;AACd;AAKO,eAAe,mBACpB,KAA8B;IAE9B,OAAO,uBAAuB;AAChC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAA8B;IAC/C,QAAQ;QAAE,QAAQ;IAA+B;IACjD,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;AAyBX,CAAC;AACD;AAEA,MAAM,yBAAyB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC1C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,IAAI,UAAU;IACd,MAAM,aAAa;IAEnB,MAAO,WAAW,WAAY;QAC5B,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,OAAO;YAChC,IAAI,CAAC,QAAQ;gBACX,MAAM,IAAI,MAAM;YAClB;YACA,OAAO;QACT,EAAE,OAAO,OAAY;YACnB,IAAI,MAAM,MAAM,KAAK,OAAO,MAAM,MAAM,KAAK,KAAK;gBAChD;gBACA,IAAI,UAAU,YAAY;oBACxB,MAAM;gBACR;gBACA,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,OAAO;YAC5D,OAAO;gBACL,MAAM;YACR;QACF;IACF;IACA,MAAM,IAAI,MAAM;AAClB;;;IApEoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 760, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/ai/flows/generate-matching-quiz.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A flow for generating a matching pairs quiz.\n *\n * - generateMatchingQuiz - A function that generates a set of matching pairs.\n * - GenerateMatchingQuizInput - The input type for the function.\n * - GenerateMatchingQuizOutput - The return type for the function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst MatchingPairSchema = z.object({\n  id: z.string().describe('A unique identifier for the pair (e.g., \"item-1\").'),\n  item: z.string().describe('The first part of the pair (e.g., a term, formula, or concept).'),\n  match: z.string().describe('The corresponding second part of the pair (e.g., a definition, unit, or explanation).'),\n});\n\nconst GenerateMatchingQuizInputSchema = z.object({\n  topic: z\n    .string()\n    .describe('The topic or subject matter for which to generate the matching quiz.'),\n});\nexport type GenerateMatchingQuizInput = z.infer<typeof GenerateMatchingQuizInputSchema>;\n\nconst GenerateMatchingQuizOutputSchema = z.object({\n  title: z.string().describe('The title of the matching quiz.'),\n  pairs: z.array(MatchingPairSchema).describe('An array of 8 matching pairs.'),\n});\nexport type GenerateMatchingQuizOutput = z.infer<typeof GenerateMatchingQuizOutputSchema>;\n\nexport async function generateMatchingQuiz(\n  input: GenerateMatchingQuizInput\n): Promise<GenerateMatchingQuizOutput> {\n  return generateMatchingQuizFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateMatchingQuizPrompt',\n  input: { schema: GenerateMatchingQuizInputSchema },\n  output: { schema: GenerateMatchingQuizOutputSchema },\n  prompt: `You are an expert AQA GCSE Science examiner.\n  Create a matching pairs quiz with exactly 8 pairs for the given topic.\n  The pairs should connect key terms to their definitions, formulas to their names, or concepts to their explanations.\n  Each pair must have a unique ID from \"item-1\" to \"item-8\".\n\n  Topic: {{{topic}}}\n  `,\n});\n\nconst generateMatchingQuizFlow = ai.defineFlow(\n  {\n    name: 'generateMatchingQuizFlow',\n    inputSchema: GenerateMatchingQuizInputSchema,\n    outputSchema: GenerateMatchingQuizOutputSchema,\n  },\n  async (input) => {\n    let retries = 0;\n    const maxRetries = 2;\n\n    while (retries <= maxRetries) {\n      try {\n        const { output } = await prompt(input);\n        if (output) {\n          return output;\n        }\n        throw new Error('Generated matching quiz output was empty.');\n      } catch (error: any) {\n        retries++;\n        if (retries > maxRetries) {\n          console.error('Final attempt failed:', error);\n          throw new Error('Failed to generate matching quiz after multiple retries.');\n        }\n        await new Promise((resolve) => setTimeout(resolve, 1000 * retries));\n      }\n    }\n    throw new Error('Failed to generate matching quiz after multiple retries.');\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;;;;;AAEA,MAAM,qBAAqB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClC,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACxB,MAAM,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC7B;AAEA,MAAM,kCAAkC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC/C,OAAO,uIAAA,CAAA,IAAC,CACL,MAAM,GACN,QAAQ,CAAC;AACd;AAGA,MAAM,mCAAmC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChD,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC3B,OAAO,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,oBAAoB,QAAQ,CAAC;AAC9C;AAGO,eAAe,qBACpB,KAAgC;IAEhC,OAAO,yBAAyB;AAClC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAAgC;IACjD,QAAQ;QAAE,QAAQ;IAAiC;IACnD,QAAQ,CAAC;;;;;;EAMT,CAAC;AACH;AAEA,MAAM,2BAA2B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC5C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,IAAI,UAAU;IACd,MAAM,aAAa;IAEnB,MAAO,WAAW,WAAY;QAC5B,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,OAAO;YAChC,IAAI,QAAQ;gBACV,OAAO;YACT;YACA,MAAM,IAAI,MAAM;QAClB,EAAE,OAAO,OAAY;YACnB;YACA,IAAI,UAAU,YAAY;gBACxB,QAAQ,KAAK,CAAC,yBAAyB;gBACvC,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,OAAO;QAC5D;IACF;IACA,MAAM,IAAI,MAAM;AAClB;;;IA9CoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 851, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/.next-internal/server/app/quiz/%5Btopic%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {chat as '404dcffc1723ab3f80a83b00432e187737b87817c7'} from 'ACTIONS_MODULE0'\nexport {generateWrittenQuestion as '40cd5ef5f169ccf328d4fd4079493d26975390993a'} from 'ACTIONS_MODULE1'\nexport {generateClozeTest as '40c88fe8a1bfd3a4530976982422010d4e03d58b42'} from 'ACTIONS_MODULE2'\nexport {explainExamQuestion as '406a3d57a5428574b61b856795866146e8b3da2a2d'} from 'ACTIONS_MODULE3'\nexport {gradeWrittenAnswer as '40a36103411b7a703aae20ee4c0e414b10ac4cd341'} from 'ACTIONS_MODULE4'\nexport {generateMatchingQuiz as '4032978d9da9ae12d8e565efdd0e08e02e18d66fbc'} from 'ACTIONS_MODULE5'\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA","debugId":null}},
    {"offset": {"line": 971, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/app/quiz/%5Btopic%5D/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/quiz/[topic]/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/quiz/[topic]/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAiS,GAC9T,+DACA","debugId":null}},
    {"offset": {"line": 985, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Niyyro3.github.io/src/app/quiz/%5Btopic%5D/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/quiz/[topic]/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/quiz/[topic]/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA6Q,GAC1S,2CACA","debugId":null}},
    {"offset": {"line": 999, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}